Exercises: Reinforcement.

R-2.1 Give three examples of life-critical software applications?

>Radiation-Therapy Machine;
Air-traffic system;
Nuclear Reactor.


R-2.2 Give an example of a software application in which adaptability can mean the
difference between a prolonged lifetime of sales and bankruptcy.

>Internet Search Engines.


R-2.3 Describe a component from a text-editor GUI and the methods that it encapsulates.


R-2.4 Assume that we change the CreditCard class (see Code Fragment 1.5) so that
instance variable balance has private visibility. Why is the following implementation of the PredatoryCreditCard.charge method flawed?

public boolean charge(double price) {
  boolean isSuccess = super.charge(price);
    if (!isSuccess)
      charge(5); // the penalty
  return isSuccess;
}

>Afeter the limit is reached this approach will cause the recursive charge to execute forever.
"super.charge(price);" will always return false.

R-2.5 Assume that we change the CreditCard class (see Code Fragment 1.5) so that
instance variable balance has private visibility. Why is the following implementation of the PredatoryCreditCard.charge method flawed?

public boolean charge(double price) {
  boolean isSuccess = super.charge(price);
    if (!isSuccess)
      super.charge(5); // the penalty
  return isSuccess;
}

>Changing the superclass instance variable balance modifier assessor to private will not cause compile time error,
because charge's PredatoryCreditCard class method make a call to the superclass CreditCard method instead of trying access it directly.
On the other hand it will cause not a compile time error nor runtime exception but will not perform any charge 
after the limit is reached.


R-2.6 Give a short fragment of Java code that uses the progression classes from Section 2.2.3 
to find the eighth value of a Fibonacci progression that starts with 2
and 2 as its first two values.

prog = new FibonacciProgression(2, 2);


If we choose an increment of 128, how many calls to the nextValue method from
the ArithmeticProgression class of Section 2.2.3 can we make before we cause a
long-integer overflow?

> 128^8 or 2^56 calls to nextValue before cause a long-integer overvflow.


R-2.8 Can two interfaces mutually extend each other? Why or why not?

> No. Cuz it will cause and cyclic inheritance invovlving compile time error.


R-2.9 What are some potential efficiency disadvantages of having very deep inheritance
trees, that is, a large set of classes, A, B, C, and so on, such that B extends A, C
extends B, D extends C, etc.?

The real question is what is the right level of abstractions to use. 
This is what impacts developer efficiency which is the most important thing to consider in 99% of cases. 
Any assumptions you make about the efficiency of how the code runs is likely to be either a) not make much difference 
or b) wrong or c) out of date in a future version of the JVM.

The most important CPU performance to worry about is time complexity, 
but more often it is developer efficiency which will cost you the most in the long run.

>The only efficiency problems for a deep inheritance tree that I can see 
is that super may be called many times over in a deep inheritance tree when calling the constructor for the deepest class.

The JVM supports aggressive inlining. 
Within reason the number of times you call super doesn't matter especially if you don't add methods which add no value.

>Also, if there is a method signature that is overridden in each class, 
the compiler will take longer to sort out or determine which method is overridden.

While this is true, the time the compiler spends compiling the code is unlikely to be important. 
If you have G extends F extends E extends D extends C extends B extends A the only methdos which call super are the ones you add.
i.e. the more levels you add the less like you need to override a method at every level. 
The JIT can also inline all these methods so it as if there was no calls from a performance point of view.

>So a bunch of classes extending one class becomes disorganized.

This is very important. It lowers the efficiency of your developers and their ability to optimise the code. i.e. it can be less performant because it is harder to optimise.



R-2.10 What are some potential efficiency disadvantages of having very shallow inheritance trees,
that is, a large set of classes, A, B, C, and so on, such that all of these
classes extend a single class, Z?

>Removing or swapping out a superclass will usually break subclasses. 
Subclasses are entirely dependant on their superclass to function effectively.
It's inflexible. You are burdened by methods and behavior defined in a more general superclass, 
making down-the-line changes and customization difficult. 
Decisions made early on haunt the entire class hierarchy. See the fragile base class problem.
So, you would at some time think that is a good idea to make some modifications, upgrades to a specific method,
but it may cause some unstable behavior for the mojority of the subclasses.



R-2.11 Consider the following code fragment, taken from some package:
public class Maryland extends State {
Maryland() { /∗ null constructor ∗/ }
public void printMe() { System.out.println("Read it."); }
public static void main(String[ ] args) {
Region east = new State();
State md = new Maryland();
Object obj = new Place();
Place usa = new Region();
md.printMe();
east.printMe();
((Place) obj).printMe();
obj = md;
((Maryland) obj).printMe();
obj = usa;
((Place) obj).printMe();
usa = md;
((Place) usa).printMe();
}
}
class State extends Region {
State() { /∗ null constructor ∗/ }
public void printMe() { System.out.println("Ship it."); }
}
class Region extends Place {
Region() { /∗ null constructor ∗/ }
public void printMe() { System.out.println("Box it."); }
}
class Place extends Object {
Place() { /∗ null constructor ∗/ }
public void printMe() { System.out.println("Buy it."); }
}
What is the output from calling the main() method of the Maryland class?

> Read it.
  Ship it.
  Buy it.
  Read it.
  Box it.
  Read it.
  
  
  
R-2.13 Consider the inheritance of classes from Exercise R-2.12, and let d be an object
variable of type Horse. If d refers to an actual object of type Equestrian, can it
be cast to the class Racer? Why or why not?

> Yes, it can be downcasted since Racer is a subclass of the type Horse like Equestrian.



R-2.15 If the parameter to the makePayment method of the CreditCard class (see Code
Fragment 1.5) were a negative number, that would have the effect of raising
the balance on the account. Revise the implementation so that it throws an
IllegalArgumentException if a negative amount is sent as a parameter.

public void makePayment(double amount) throws IlligalArgumentException { // make a payment
        if(amount < 0)
            throw new IlligalArgumentException();
        else
        balance -= amount;
        
    }
